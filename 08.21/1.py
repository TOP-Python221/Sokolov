from math import sqrt


# ДОБАВИТЬ: документацию класса
class Tetrahedron:
    def __init__(self, edge: float):
        # КОММЕНТАРИЙ: здесь для присвоения значения вызывается сеттер
        self.edge = edge
        # ИСПОЛЬЗОВАТЬ: а вот это запись непосредственно в атрибут — для наглядности разницы
        # self._edge = edge

    # КОММЕНТАРИЙ: в этой задаче не было необходимости использовать свойства, но если уж используете, то делайте это правильно — у вас скрипт уходил в бесконечную рекурсию
    @property
    def edge(self) -> float:
        # КОММЕНТАРИЙ: геттер не должен возвращать сам себя — а именно это вы здесь делаете, отсюда и рекурсия
        # return self.edge
        # ИСПОЛЬЗОВАТЬ: в таком простом случае геттер возвращает значение частного (private) или защищённого (protected) атрибута
        return self._edge

    @edge.setter
    def edge(self, value):
        # КОММЕНТАРИЙ: обычно геттер возвращает значение именно того атрибута, в который присваивает сеттер
        self._edge = value

    # ДОБАВИТЬ: документацию не специального метода
    def volume(self) -> float:
        # КОММЕНТАРИЙ: а здесь и в следующем методе во время вычисления вызывается геттер
        return self.edge**3 * sqrt(2) / 12

    def surface(self):
        return self.edge**2 * sqrt(3)


tet = Tetrahedron(5)
print(f'{tet.edge = :.2f}\t{tet.volume = :.2f}')


# СДЕЛАТЬ: пройдите по этому коду пошагово в режиме отладки, отслеживая переход от метода к методу и стек вызовов, чтобы детально понять, как выполняется код


# ДОБАВИТЬ: примеры выполнения скрипта в закомментированном виде под меткой tests
# tests:


# ИТОГ: не считая свойств и отсутствия документации, хорошо — 5/7
